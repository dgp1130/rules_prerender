"""Defines the `css_map()` rule."""

load(":css_providers.bzl", "CssImportMapInfo", "CssInfo")

def _css_map_impl(ctx):
    return [
        ctx.attr.bin[DefaultInfo],
        CssImportMapInfo(import_map = _make_import_map(ctx)),
    ]

css_map = rule(
    implementation = _css_map_impl,
    attrs = {
        "bin": attr.label(
            mandatory = True,
            doc = """
The `postcss_multi_binary()` target which compiles the library. Files generated by this
target are used as the actual files paths in the provided `CssImportMapInfo`.
            """.strip(),
        ),
        "lib": attr.label(
            mandatory = True,
            providers = [CssInfo],
            doc = """
The `css_library()` target containing direct sources used in the `postcss_multi_binary()`.
Files included here are used to define the user-authorable import path in the provided
`CssImportMapInfo`.
            """.strip(),
        ),
    },
    doc = """
Provides a `CssImportMapInfo` which maps the user-authorable import path to the actual
file path to resolve to.
    """.strip(),
)

def _make_import_map(ctx):
    lib_files = sorted(ctx.attr.lib[CssInfo].direct_sources)
    bin_files = sorted([file for file in ctx.files.bin if not file.basename.endswith(".map")])

    # Validate that the `postcss_binary()` and the `css_library()` contain the same number
    # of files.
    if len(lib_files) != len(bin_files):
        fail(("Number of files from the CSS library (%s from %s) does not equal the" +
              " number of files from the CSS binary (%s from %s)") % (
                  len(lib_files),
                  ctx.attr.lib.label,
                  len(bin_files),
                  ctx.attr.bin.label,
             ))

    import_map = dict()
    lib_wksp = (ctx.attr.lib.label.workspace_name
                if ctx.attr.lib.label.workspace_name
                else ctx.workspace_name)
    for index in range(len(lib_files)):
        lib_file = lib_files[index]
        bin_file = bin_files[index]

        # The library and binary file should have the same name, but might be in
        # different packages.
        if lib_file.basename != bin_file.basename:
            fail(("CSS library files did not match up with CSS binary files.\n" +
                  "Lib files:\n%s\n\nBin files:\n%s") % (
                      "\n".join([file.path for file in lib_files]),
                      "\n".join([file.path for file in bin_files]),
                  ))

        # Verify that the importable path isn't already registered.
        key = "%s/%s" % (lib_wksp, lib_file.short_path)
        if key in import_map:
            fail("CSS library file (%s) mapped twice, once to %s and a second time to %s." % (
                key,
                import_map[key].path,
                bin_file.path,
            ))

        import_map[key] = bin_file

    return import_map
