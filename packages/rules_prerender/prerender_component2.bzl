"""Defines `prerender_component()` functionality."""

load("@aspect_rules_js//js:defs.bzl", "js_library")
load("@aspect_rules_js//js:providers.bzl", "JsInfo", "js_info")
load("@aspect_rules_ts//ts:defs.bzl", "ts_project")
load("//common:label.bzl", "absolute")
load("//common:paths.bzl", "is_js_file", "is_ts_file", "is_ts_declaration_file")
load("//packages/rules_prerender/css:css_binaries.bzl", "css_binaries")
load("//packages/rules_prerender/css:css_group.bzl", "css_group")
load("//packages/rules_prerender/css:css_library.bzl", "css_library")
load(
    ":prerender_metadata.bzl",
    "PrerenderMetadataInfo",
    "alias_with_metadata",
    "prerender_metadata",
)
load(":visibility_aspect.bzl", "VisibilityInfo", "visibility_aspect")
load(":web_resources.bzl", "web_resources")

visibility("public")

def prerender_component(
    name,
    prerender,
    scripts = None,
    styles = None,
    resources = None,
    testonly = None,
    visibility = None,
):
    """Encapsulates an HTML/JS/CSS component for use in prerendering a web page.

    This rule encapsulates the HTML, JavaScript, CSS, and static resources used
    by a logical "component". A "component" is effectively a prerendered
    fragment of HTML which provides some functionality (via JavaScript) and
    styling (via CSS) with any required static files (ex. an image) at a
    specific path (ex. /my-logo.png). Components are reusable pieces of UI which
    can be composed together to build a complex static site.

    IMPORTANT: `prerender_component()` has some special rules about _how_ it can
    be used. It doesn't inherently _do_ anything special. It only collects all
    the various parts of a component (HTML, scripts, styles, resources) with
    some extra metadata for the bundling process and re-exports them at
    `%{name}_prerender`, `%{name}_scripts`, `%{name}_styles`, and
    `%{name}_resources`.
    
    A `prerender_component()` should _not_ be depended upon directly, instead
    you should depend on the re-exports for the specific parts of the component
    you need. The bundling process will bundle the entire component for you as
    expected. For example:

    ```BUILD
    # my_component/BUILD.bazel

    prerender_component(
        name = "my_component",
        prerender = ":prerender",
    )

    # IMPORTANT! No target except `:my_component` should depend on this. If they
    # do, the generated site may be missing scripts, styles, resources, etc.
    ts_project(
        name = "prerender",
        srcs = ["my_component_prerender.mts"],
    )
    ```

    ```BUILD
    # my_other_component/BUILD.bazel

    prerender_component(
        name = "my_other_component",
        prerender = ":my_other_component_prerender_lib",

        # No dependency on `//my_component/...` here.
    )

    ts_project(
        name = "prerender",
        srcs = ["my_other_component_prerender.mts"],

        # IMPORTANT! Depend on the `_prerender` alias generated by
        # `prerender_component()`. DON'T depend on `//my_component:prerender`
        # directly.
        deps = ["//my_component:my_component_prerender"],
    )
    ```

    The rules here are:
    1.  Any direct dependency of a `prerender_component()` target should _only_
        be used by that `prerender_component()`.
    2.  Any additional desired dependencies, should go through the relevant
        `_prerender`, `_scripts`, `_styles`, `_resources` re-export generated by
        the `prerender_component()` macro.
        *   Exception: Unit tests may directly depend on targets provided they
            do not use any `prerender_*` rules in the test.
    3.  Never depend on a `prerender_component()` directly, always depend on the
        specific re-export you want.
        *   Exception: You may `bazel build` a `prerender_component()` target or
            have a `build_test()` depend on it to verify that it is buildable.
    4.  Any direct dependency of a `prerender_component()` target *must* be
        defined in the same Bazel package and have private visibility.
        *   This is enforced at build time.
        *   Acts as a guardrail to make it less likely to run afoul of the above
            rules.
    
    Args:
        name: The name of this rule.
        prerender: Required. A `ts_project()` target which acts as a library for
            prerendering at build time.
        scripts: A `ts_project()` holding client-side scripts for this
            component.
        styles: A `css_library()` holding the styles for this component.
        resources: A `web_resources()` target holding other static files needed
            by this component at runtime.
        testonly: See https://docs.bazel.build/versions/master/be/common-definitions.html.
        visibility: See https://docs.bazel.build/versions/master/be/common-definitions.html.
    
    Outputs:
        %{name}: A library which verifies that all the different aspects of the
                 component are buildable and runs various sanity checks.
        %{name}_prerender: A reexport of the `prerender` attribute.
        %{name}_scripts: A reexport of the `scripts` attribute.
        %{name}_styles: A reexport of the `styles` attribute.
        %{name}_resources: A reexport of the `resources` attribute.
    """
    # Build all dependencies and sanity check the component. This allows
    # `bazel build` of a `prerender_component` to validate that the component is
    # buildable and usable.
    _component_check(
        name = name,
        prerender = prerender,
        scripts = scripts,
        styles = styles,
        resources = resources,
        testonly = testonly,
        # Explicitly private because this just validates that the component is
        # buildable. It should never be depended upon directly.
        visibility = ["//visibility:private"],
    )

    styles_reexport = "%s_styles_reexport" % name
    if styles:
        _inline_css_reexport(
            name = styles_reexport,
            styles = styles,
            visibility = visibility,
            testonly = testonly,
        )

    # Metadata provider.
    metadata = "%s_metadata" % name
    prerender_metadata(
        name = metadata,
        prerender = prerender,
        scripts = scripts,
        styles = ":%s" % styles_reexport if styles else None,
        styles_import_map = ":%s" % styles_reexport if styles else None,
        resources = resources,
        # Include `_component_check()` output to run its Starlark implementation
        # and run its sanity checks.
        component_check = ":%s" % name,
        testonly = testonly,
    )

    # Prerendering JavaScript.
    alias_with_metadata(
        name = "%s_prerender" % name,
        metadata = ":%s" % metadata,
        actual = prerender,
        visibility = visibility,
        testonly = testonly,
    )

    # Client-side JavaScript.
    scripts_target = "%s_scripts" % name
    if scripts:
        alias_with_metadata(
            name = scripts_target,
            metadata = ":%s" % metadata,
            actual = scripts,
            visibility = visibility,
            testonly = testonly,
        )
    else:
        js_library(
            name = scripts_target,
            srcs = [],
            visibility = visibility,
            testonly = testonly,
        )

    # CSS styles.
    styles_target = "%s_styles" % name
    if styles:
        alias_with_metadata(
            name = styles_target,
            metadata = metadata,
            actual = ":%s" % styles_reexport,
            testonly = testonly,
            visibility = visibility,
        )

    # Resources.
    resources_target = "%s_resources" % name
    if resources:
        alias_with_metadata(
            name = resources_target,
            metadata = ":%s" % metadata,
            actual = resources,
            visibility = visibility,
            testonly = testonly,
        )

def _component_check_impl(ctx):
    # Identify all the provided slices and what kind of dependency edge they use.
    nullable_slices = {
        "prerender": ctx.attr.prerender,
        "scripts": ctx.attr.scripts,
        "styles": ctx.attr.styles,
        "resources": ctx.attr.resources,
    }
    slices = {edge: slice for (edge, slice) in nullable_slices.items() if slice}

    for (edge, slice) in slices.items():
        # Check slice is in the same package.
        if slice.label.package != ctx.label.package:
            fail("""
{target} depends on {slice} which is in a different Bazel package (BUILD file).

Direct dependencies of `prerender_component` targets *must* be defined in the same package. This allows `prerender_component` to properly encapsulate all the aspects of a component.

Possible solutions:
1.  If {slice} is only used by {target}, move {slice} into {package}.
2.  If {slice} is used elsewhere, make a `prerender_component` in {dep_package} to encapsulate that target. Then use that new component from {target} just like any other.
            """.strip().format(
                target = ctx.label,
                slice = slice.label,
                package = "//%s" % ctx.label.package,
                dep_package = "//%s" % slice.label.package,
            ))

        # Check slice has private visibility.
        visibility = slice[VisibilityInfo].visibility
        non_private_visibility = [scope for scope in visibility
                                  if scope != Label("//visibility:private")]
        if non_private_visibility:
            fail("""
{slice} must have private visibility. Any dependencies on it should depend on {component_slice} instead.

Direct dependencies of `prerender_component` targets *must* have private visibility so all incoming dependencies flow through {component_slice} instead. This allows `@rules_prerender` to collect all the different parts of a component and bundle them correctly.

Solution: Update {slice} to use private visibility. This can be done by deleting the `visibility` attribute (Bazel targets are private by default).

{slice} is currently visible to:
{visibility}
            """.strip().format(
                slice = slice.label,
                component_slice = "%s_%s" % (ctx.label, edge),
                visibility = "\n".join([str(label) for label in non_private_visibility]),
            ))

    # Collect all the `DefaultInfo` outputs of the component slices and return
    # them so `bazel build`-ing a `prerender_component` implicitly builds all
    # its dependencies.
    files_to_build = [ctx.attr.prerender[DefaultInfo].files]
    if ctx.attr.scripts:
        files_to_build.append(ctx.attr.scripts[DefaultInfo].files)
    if ctx.attr.styles:
        files_to_build.append(ctx.attr.styles[DefaultInfo].files)
    if ctx.attr.resources:
        files_to_build.append(ctx.attr.resources[DefaultInfo].files)
    return DefaultInfo(
        files = depset([], transitive = files_to_build),
    )

_component_check = rule(
    implementation = _component_check_impl,
    attrs = {
        "prerender": attr.label(
            mandatory = True,
            aspects = [visibility_aspect],
        ),
        "scripts": attr.label(aspects = [visibility_aspect]),
        "styles": attr.label(aspects = [visibility_aspect]),
        "resources": attr.label(aspects = [visibility_aspect]),
    },
    doc = "Performs component-level sanity checks and builds all slices.",
)

def _js_reexport_impl(ctx):
    merged_js_info = js_info(
        declarations = depset([],
            transitive = [src[JsInfo].declarations
                          for src in ctx.attr.srcs],
        ),
        npm_linked_package_files = depset([],
            transitive = [src[JsInfo].npm_linked_package_files
                          for src in ctx.attr.srcs],
        ),
        npm_linked_packages = depset([],
            transitive = [src[JsInfo].npm_linked_packages
                          for src in ctx.attr.srcs],
        ),
        npm_package_store_deps = depset([],
            transitive = [src[JsInfo].npm_package_store_deps
                          for src in ctx.attr.srcs],
        ),
        sources = depset([],
            transitive = [src[JsInfo].sources
                          for src in ctx.attr.srcs],
        ),
        transitive_declarations = depset([],
            transitive = [dep[JsInfo].transitive_declarations
                          for dep in ctx.attr.srcs + ctx.attr.deps],
        ),
        transitive_npm_linked_package_files = depset([],
            transitive = [dep[JsInfo].transitive_npm_linked_package_files
                          for dep in ctx.attr.srcs + ctx.attr.deps],
        ),
        transitive_npm_linked_packages = depset([],
            transitive = [dep[JsInfo].transitive_npm_linked_packages
                          for dep in ctx.attr.srcs + ctx.attr.deps],
        ),
        transitive_sources = depset([],
            transitive = [dep[JsInfo].transitive_sources
                          for dep in ctx.attr.srcs + ctx.attr.deps],
        ),
    )

    return [
        DefaultInfo(files = merged_js_info.sources),
        merged_js_info,
    ]

_js_reexport = rule(
    implementation = _js_reexport_impl,
    attrs = {
        "srcs": attr.label_list(
            default = [],
            providers = [JsInfo],
        ),
        "deps": attr.label_list(
            default = [],
            providers = [JsInfo],
        ),
    },
    doc = """
        Re-exports the given `ts_project()` and `js_library()` targets. Targets
        in `srcs` have their direct sources re-exported as the direct sources of
        this target, while targets in `deps` are only included as transitive
        sources.

        This rule serves two purposes:
        1.  It re-exports **both** `ts_project()` and `js_library()`.
        2.  It merges multiple targets together, depending on all of them but
            only re-exporting direct sources from the `srcs` attribute. Even
            with `ts_project()` re-export it is not possible to re-export only
            some of the given targets.
    """,
)

def _inline_css_reexport(name, styles, testonly = None, visibility = None):
    css_binaries(
        name = name,
        testonly = testonly,
        deps = [styles],
    )
